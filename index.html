<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js" ></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js" ></script>
  
  <script>

    function processParams(){
      const urlParams = new URLSearchParams(window.location.search);
      try {
        //failure can be exception, or null
        console.log("Checking for params");

        var simulate = urlParams.get('simulate')=='true';

        console.log(`simulate: ${simulate}`);

        var params = JSON.parse(atob(urlParams.get('params')));

        if (null == params) {
          throw "Combo parse failed.";
        } else {
          console.log("Successfully parsed encoded params");
        }
      } catch (e) {
        console.log("Combo failed. Dropping through to individual params");
        var params = {
          lat: parseFloat(urlParams.get('lat')),
          lon: parseFloat(urlParams.get('lon')),
          alt: parseFloat(urlParams.get('alt')),
          scale: parseFloat(urlParams.get('scale')),
          opacity: parseFloat(urlParams.get('opacity')),
          revspersec: parseFloat(urlParams.get('revspersec'))
        };
      }
      params.simulate = simulate;

      console.log("using the following params:");
      console.log(params);
      return params;
    }

    //THANKYOU: https://stackoverflow.com/a/61443888
    function changeReadOnlyLocations(params){
      var sceneEl = document.querySelector('a-scene');
      var el = sceneEl.querySelector("#model");

      console.log("processing location");

      if (!isNaN(params.lon) && !isNaN(params.lon)) {
        var loc = `latitude: ${params.lat}; longitude: ${params.lon};`;
        
        console.log(`substituting coordinates: ${loc}`);
        var gps = document.createAttribute("gps-projected-entity-place");
        gps.value  = loc;
        el.setAttributeNode(gps);

        if(params.simulate){
          console.log('simulating location');
          var cameraEl = sceneEl.querySelector('a-camera');
          cameraEl.setAttribute('simulateLatitude', params.lat);
          cameraEl.setAttribute('simulateLongitude', params.lon);
        }

      } else {
        console.log("No coordinates found.");
      }
    }

    window.onload = function() {
      var params = processParams();
      changeReadOnlyLocations(params);
      window.reallyHackyGlobalLocation = params;
    }

</script>

<script>
  AFRAME.registerComponent('scalechanger', {
  init: function () {
    var params = window.reallyHackyGlobalLocation;
    
    if(!isNaN(params.scale)){
      this.el.setAttribute('scale',{x:params.scale, y:params.scale, z:params.scale}, true);
      }else{
        console.log("no scale found.");
      }
  }
});
</script>

<script>
  AFRAME.registerComponent('positionchanger', {
  init: function () {
    var params = window.reallyHackyGlobalLocation;
    if(!isNaN(params.alt)){
      var pos = this.el.getAttribute('position');
      this.el.setAttribute('position',{x:pos.x, y:params.alt, z:pos.z},true);
      }else{
        console.log("no position found.");
      }
  }
});
</script>

<script>
  AFRAME.registerComponent('opacitychanger', {

  init: function () {
    this.el.addEventListener('model-loaded', () =>{
  
      var params = window.reallyHackyGlobalLocation;
      var opacity = params.opacity;
      if (!isNaN(opacity)){
        var mesh = this.el.getObject3D('mesh');
        if (!!mesh) {  
          mesh.traverse(function (node) {
            if (node.isMesh) {
              node.material.opacity = opacity;
              node.material.transparent = opacity < 1.0;
              node.material.needsUpdate = true;
            }else{
              console.log("node not mesh")
            }
          });
        }else{
          console.log("no nodes found");
        }
      }else{
        console.log("parameter 'opacity' not found");
      }

    });
  }
});
</script>

<script>
  AFRAME.registerComponent('spinchanger', {


  init: function () {
    var params = window.reallyHackyGlobalLocation;
    this.revspersec = 0.6;//params.revspersec;
    this.meshes = [];
    this.lastTime_ms = 0;
    this.timeToUpdate_ms = 0;
    this.sectorCount = 0;
    this.sectorsperrev=300;
    var self = this;
    this.el.addEventListener('model-loaded', () =>{
      var revspersec = self.revspersec;
      if ((!isNaN(revspersec)) && (revspersec > 0)){
        var mesh = self.el.getObject3D('mesh');
        if (!!mesh) {  
          mesh.traverse(function (node) {
            if (node.isMesh) {
              self.meshes.push(node);
            }
          });
        }

      }else{
        console.log("parameter 'opacity' not found");
      }

    });
  },

    tick: function () {


      const rotateAbout = (mesh, axis, axisPosition, angle) => {
    mesh.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(mesh.position.x-axisPosition.x, mesh.position.y-axisPosition.y, mesh.position.z-axisPosition.z));  //translate geometry to axis location
    mesh.geometry.applyMatrix(new THREE.Matrix4().makeRotationAxis(axis, angle));    //rotate geometry about axis
    mesh.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(axisPosition.x-mesh.position.x, axisPosition.y-mesh.position.y, axisPosition.z-mesh.position.z));  //translate geometry back to original location
    }

      var revspersec = this.revspersec;
      var meshes = this.meshes;
      var sectorsperrev = this.sectorsperrev;
      var radspersector = 2 * Math.PI / sectorsperrev;

      lastTime_ms = this.lastTime_ms;

      if((revspersec > 0)&&(meshes.length > 0)){
        var secsperrev = 1 / revspersec;
        var timepersector_ms = secsperrev * 1000 / sectorsperrev;
        
        var time_ms = Date.now();
        var timeDiff_ms = time_ms - lastTime_ms;
        this.lastTime_ms = time_ms;

        this.timeToUpdate_ms -= timeDiff_ms;
        if(this.timeToUpdate_ms <= 0){
          this.timeToUpdate_ms = timepersector_ms;

          var sectorCount = this.sectorCount + 1;
          if(sectorCount > sectorsperrev){
            sectorCount = 0;
          }
          this.sectorCount = sectorCount;
          rotation = radspersector * sectorCount;

          meshes.forEach(mesh => {
            mesh.rotation.x = rotation;
          });
        }
      }
    },
});
</script>



</head>
<body style="margin: 0; overflow: hidden;">
  <a-scene 
    fog="type: exponential; color: #AAA; density: 0.0005" 
    renderer="logarithmicDepthBuffer: true;"
    embedded 
    loading-screen="enabled: true;" 
    arjs="sourceType: webcam; debugUIEnabled: false;">
    <a-assets  timeout="100000">
      <a-asset-item id="model-asset" src="./assets/model.glb" />
    </a-assets>

    <a-entity 
      id="model"
      gltf-model="#model-asset"
      opacitychanger
      positionchanger
      scalechanger
      spinchanger
      scale="1 1 1" 
      position="0 0 0" 
      rotation="0 0 0">
    </a-entity>

    <a-camera gps-projected-camera read-rotation></a-camera>
  </a-scene>
</body>

</html>