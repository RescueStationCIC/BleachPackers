<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js" ></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js" ></script>
  
  <script>

    function processParams(){
      console.log("processParams");
      const urlParams = new URLSearchParams(window.location.search);
      try {
        var simulate = urlParams.get('simulate')=='true';

        console.log(`simulate: ${simulate}`);

        var params = JSON.parse(atob(urlParams.get('params')));

        if (null == params) {
          throw "Combo parse failed.";
        } else {
          console.log("Successfully parsed encoded params");
        }
      } catch (e) {
        console.log("Combo failed. Dropping through to individual params");
        var params = {
          lat: parseFloat(urlParams.get('lat')),
          lon: parseFloat(urlParams.get('lon')),
          alt_m: parseFloat(urlParams.get('alt_m')),
          height_m: parseFloat(urlParams.get('height_m')),
          opacity: parseFloat(urlParams.get('opacity')),
          period_s: parseFloat(urlParams.get('period_s'))
        };
      }
      params.simulate = simulate;

      console.log("using the following params:");
      console.log(params);
      return params;
    }

    //THANKYOU: https://stackoverflow.com/a/61443888
    function changeReadOnlyLocations(params){
      console.log("changeReadOnlyLocations");

      var sceneEl = document.querySelector('a-scene');
      var el = sceneEl.querySelector("#model");

      console.log("processing location");

      if (!isNaN(params.lon) && !isNaN(params.lon)) {
        var loc = `latitude: ${params.lat}; longitude: ${params.lon};`;
        
        console.log(`substituting coordinates: ${loc}`);
        var gps = document.createAttribute("gps-entity-place");
        gps.value  = loc;
        el.setAttributeNode(gps);

        if(params.simulate){
          console.log('simulating location');
          var cameraEl = sceneEl.querySelector('a-camera');
          cameraEl.setAttribute('simulateLatitude', params.lat);
          cameraEl.setAttribute('simulateLongitude', params.lon);
        }

      } else {
        console.log("No coordinates found.");
      }
    }

    window.onload = function() {
      var params = processParams();
      changeReadOnlyLocations(params);
      window.reallyHackyGlobalLocation = params;
    }

</script>




<script>
  AFRAME.registerComponent('opacitychanger', {

  init: function () {
    this.el.addEventListener('model-loaded', () =>{
      console.log("opacitychanger:init");
      var params = window.reallyHackyGlobalLocation;
      var opacity = params.opacity;
      if (isNaN(opacity)){
        opacity = 0.6; // default
      }
      var mesh = this.el.getObject3D('mesh');
      if (!!mesh) {  
        mesh.traverse(function (node) {
          if (node.isMesh) {
            node.material.opacity = opacity;
            node.material.transparent = opacity < 1.0;
            node.material.needsUpdate = true;
          }
        });
      }else{
        console.log("no nodes found");
      }


    });
  }
});
</script>

<script>
  AFRAME.registerComponent('spatialchanger', {


  init: function () {

    function positionAndScale(gltf, height_m, alt_m){
      // THANKYOU: https://stackoverflow.com/a/52271526

      var mroot = gltf.scene;
      var bbox = new THREE.Box3().setFromObject(mroot);
      var cent = bbox.getCenter(new THREE.Vector3());
      var size = bbox.getSize(new THREE.Vector3());

      //Rescale the object to normalized space
      var maxAxis = Math.max(size.x, size.y, size.z);
      mroot.scale.multiplyScalar((1.0 / maxAxis) * height_m);
      bbox.setFromObject(mroot);
      bbox.getCenter(cent);
      bbox.getSize(size);
      //Reposition to 0,halfY,0
      mroot.position.copy(cent).multiplyScalar(-1);
      mroot.position.y+= (size.y * 0.5) + alt_m;
    }

    function beginRotation(component, period_s, sectorsperrev){
      component.valid = false;
      component.meshes = [];
      component.center = null;
      let tickTime_ms = period_s / sectorsperrev * 1000;
      component.tick = AFRAME.utils.throttleTick(component.tick, tickTime_ms, component);
      
      component.radspersector = 2 * Math.PI / sectorsperrev;

      // store meshes, so they are not retraversed on each tick
      var meshes = component.meshes;
      var parent = component.el.getObject3D('mesh');
      if (!!parent) {  
        parent.traverse(function (node) {
          if (node.isMesh) {
            meshes.push(node);
          }
        });
      }

      if(meshes.length > 0){
          // group the meshes together
          const group = new THREE.Group();
          const boundingBox = new THREE.Box3();
          
          meshes.forEach(function(mesh){
            group.add(mesh); // this will clobber the mesh's parent
          });

          // place a bounding box around the group to get the centre
          boundingBox.setFromObject( group );
          component.center = boundingBox.getCenter();

          meshes.forEach(function(mesh){
            parent.add(mesh); //re-instate the mesh's parent
          });

          //ready for ticks
          component.valid = true;
      }
    
    }

    console.log("spatialchanger:init");
  
    var params = window.reallyHackyGlobalLocation;
    var period_s = params.period_s;
    var sectorsperrev= params.sectorsperrev;
    var height_m = params.height_m;
    var alt_m = params.alt_m;

    if (isNaN(period_s)){
      period_s = 0; //default, no rotation
    }
    if((isNaN(sectorsperrev)) || (sectorsperrev == 0) ){
      sectorsperrev = 300; // default
    }

    if(isNaN(alt_m)){
      alt_m = 1;
    }

    if(isNaN(height_m) || (height_m == 0)){
      height_m = 5.0;
    }

    var component = this;

    this.el.addEventListener('model-loaded', (event) =>{

      var gltf = {
        scene: event.detail.model
      };

      // gltf models all seem to be offset from the origin. 
      // apply a correction: reset the model's origin, coincident with the scene's center
      // and scale, such that the model's height is in M.
      positionAndScale(gltf,height_m, alt_m);

      if(period_s > 0){
        beginRotation(component, period_s, sectorsperrev);
      }
      
    });
    
    
  },

    tick: function () {
      // THANK YOU: https://stackoverflow.com/questions/64218715/how-do-i-rotate-a-mesh-group-about-the-axis-of-a-random-3d-object-mesh-3d-line-w
      const rotateAbout = function (mesh, axis, axisPosition, angle) {
        mesh.geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(mesh.position.x-axisPosition.x, mesh.position.y-axisPosition.y, mesh.position.z-axisPosition.z));  //translate geometry to axis location
        mesh.geometry.applyMatrix4(new THREE.Matrix4().makeRotationAxis(axis, angle));    //rotate geometry about axis  
        mesh.geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(axisPosition.x-mesh.position.x, axisPosition.y-mesh.position.y, axisPosition.z-mesh.position.z));  //translate geometry back to original location
      }

      if(this.valid){
        var meshes = this.meshes;
        var center = this.center;
        var rotation = this.radspersector;
        meshes.forEach(function(mesh){
            rotateAbout(mesh, new THREE.Vector3(0,1,0), center, rotation); 
          });
      }
    },
});
</script>

<style>
  .on {
    background: url(./assets/Speaker_Icon.svg) no-repeat 50% 50%;
    background-size: contain;
    position: absolute;
    border: none;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 5em;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10;
  }

  .on.off {
    background: url(./assets/Mute_Icon.svg)  no-repeat 50% 50%;
    background-size: contain;
  }
</style>

</head>
<body style="margin: 0; overflow: hidden;">
  <audio id="backing">
    <source src="./assets/windchime.mp3" type="audio/mpeg">
  </audio>
  <input type="button" id="toggle" class="on" onclick="togglestyle(this)" />
  <a-scene 
    fog="type: exponential; color: #AAA; density: 0.0005" 
    renderer="logarithmicDepthBuffer: true;"
    vr-mode-ui="enabled: false"

    arjs="sourceType: webcam; debugUIEnabled: false;">
    <a-assets  timeout="100000">
      <a-asset-item id="model-asset" src="./assets/model.glb" />
    </a-assets>

    <a-entity 
      id="model"
      gltf-model="#model-asset"
      spatialchanger
      opacitychanger
      >
 
    </a-entity>


    <a-camera gps-camera read-rotation></a-camera>
  </a-scene>
</body>

<script language="javascript">
  var backingEl = document.getElementById("backing");
  var toggleEl = document.getElementById("toggle");

  function onPlay(){
      backingEl.play();
      toggleEl.className="on off";
  }

  function onPause(){
    backingEl.pause();
    toggleEl.className="on";
  }

  function togglestyle(el){      
      if(el.className == "on") {
        onPlay();
      } else {
        onPause();
      }
  }

  backingEl.onended = function(event){
    onPause();
  }
</script>


</html>