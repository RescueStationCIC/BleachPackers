<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js" ></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js" ></script>
  
  <script>

    function processParams(){
      console.log("processParams");
      const urlParams = new URLSearchParams(window.location.search);
      try {
        var simulate = urlParams.get('simulate')=='true';

        console.log(`simulate: ${simulate}`);

        var params = JSON.parse(atob(urlParams.get('params')));

        if (null == params) {
          throw "Combo parse failed.";
        } else {
          console.log("Successfully parsed encoded params");
        }
      } catch (e) {
        console.log("Combo failed. Dropping through to individual params");
        var params = {
          lat: parseFloat(urlParams.get('lat')),
          lon: parseFloat(urlParams.get('lon')),
          alt: parseFloat(urlParams.get('alt')),
          scale: parseFloat(urlParams.get('scale')),
          opacity: parseFloat(urlParams.get('opacity')),
          period_s: parseFloat(urlParams.get('period_s'))
        };
      }
      params.simulate = simulate;

      console.log("using the following params:");
      console.log(params);
      return params;
    }

    //THANKYOU: https://stackoverflow.com/a/61443888
    function changeReadOnlyLocations(params){
      console.log("changeReadOnlyLocations");

      var sceneEl = document.querySelector('a-scene');
      var el = sceneEl.querySelector("#model");

      console.log("processing location");

      if (!isNaN(params.lon) && !isNaN(params.lon)) {
        var loc = `latitude: ${params.lat}; longitude: ${params.lon};`;
        
        console.log(`substituting coordinates: ${loc}`);
        var gps = document.createAttribute("gps-projected-entity-place");
        gps.value  = loc;
        el.setAttributeNode(gps);

        if(params.simulate){
          console.log('simulating location');
          var cameraEl = sceneEl.querySelector('a-camera');
          cameraEl.setAttribute('simulateLatitude', params.lat);
          cameraEl.setAttribute('simulateLongitude', params.lon);
        }

      } else {
        console.log("No coordinates found.");
      }
    }

    window.onload = function() {
      var params = processParams();
      changeReadOnlyLocations(params);
      window.reallyHackyGlobalLocation = params;
    }

</script>

<script>
  AFRAME.registerComponent('scalechanger', {
  init: function () {
    console.log("scalechanger:init");
    var params = window.reallyHackyGlobalLocation;
    var scale = params.scale;
    if(isNaN(scale)){
      scale = 1; //default
    }
    this.el.setAttribute('scale',{x:scale, y:scale, z:scale}, true);
    
  }
});
</script>

<script>
  AFRAME.registerComponent('positionchanger', {
  init: function () {
    console.log("positionchanger:init");
    var params = window.reallyHackyGlobalLocation;
    var alt = params.alt;
    if(isNaN(alt)){
      alt = 0; // default
    }
    var pos = this.el.getAttribute('position');
    this.el.setAttribute('position',{x:pos.x, y:alt, z:pos.z},true);
      
  }
});
</script>

<script>
  AFRAME.registerComponent('opacitychanger', {

  init: function () {
    this.el.addEventListener('model-loaded', () =>{
      console.log("opacitychanger:init");
      var params = window.reallyHackyGlobalLocation;
      var opacity = params.opacity;
      if (isNaN(opacity)){
        opacity = 0.6; // default
      }
      var mesh = this.el.getObject3D('mesh');
      if (!!mesh) {  
        mesh.traverse(function (node) {
          if (node.isMesh) {
            node.material.opacity = opacity;
            node.material.transparent = opacity < 1.0;
            node.material.needsUpdate = true;
          }else{
            console.log("node not mesh")
          }
        });
      }else{
        console.log("no nodes found");
      }


    });
  }
});
</script>

<script>
  AFRAME.registerComponent('spinchanger', {


  init: function () {
    console.log("spinchanger:init");
    this.valid = false;
    this.meshes = [];
    this.group = new THREE.Group();
    this.groupBb = new THREE.Box3();
    this.groupBbCenter = null;
    
  
    var params = window.reallyHackyGlobalLocation;
    var period_s = params.period_s;
    var sectorsperrev= params.sectorsperrev;


    if (isNaN(period_s)){
      period_s = 0; //default
    }
    if((isNaN(sectorsperrev)) || (sectorsperrev == 0) ){
      sectorsperrev = 300; // default
    }
    if(period_s > 0){
      let tickTime_ms = period_s / sectorsperrev * 1000;
      this.tick = AFRAME.utils.throttleTick(this.tick, tickTime_ms, this);
      
      this.radspersector = 2 * Math.PI / sectorsperrev;

      var self = this;

      this.el.addEventListener('model-loaded', () =>{

        var meshes = self.meshes;
        var parent = self.el.getObject3D('mesh');
        if (!!parent) {  
          parent.traverse(function (node) {
            if (node.isMesh) {
              meshes.push(node);
            }
          });
        }
        if(meshes.length > 0){
          meshes.forEach(function(mesh){
            self.group.add(mesh);
          });
          self.groupBb.setFromObject( self.group );
          self.groupBbCenter = self.groupBb.getCenter();
          meshes.forEach(function(mesh){
            parent.add(mesh);
          });
          self.valid = true;
        }
      });
    }
    
    
  },

    tick: function () {

      // THANK YOU: https://stackoverflow.com/questions/64218715/how-do-i-rotate-a-mesh-group-about-the-axis-of-a-random-3d-object-mesh-3d-line-w
      const rotateAbout = (mesh, axis, axisPosition, angle) => {
        mesh.geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(mesh.position.x-axisPosition.x, mesh.position.y-axisPosition.y, mesh.position.z-axisPosition.z));  //translate geometry to axis location
        mesh.geometry.applyMatrix4(new THREE.Matrix4().makeRotationAxis(axis, angle));    //rotate geometry about axis
        mesh.geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(axisPosition.x-mesh.position.x, axisPosition.y-mesh.position.y, axisPosition.z-mesh.position.z));  //translate geometry back to original location
      }

      if(this.valid){
        var meshes = this.meshes;
        var center = this.groupBbCenter;
        var rotation = this.radspersector;
        meshes.forEach(function(mesh){
            rotateAbout(mesh, new THREE.Vector3(0,1,0), center, rotation);
          });
      }
    },
});
</script>

<style>
  .on {
    background: url(/assets/Speaker_Icon.svg) no-repeat 50% 50%;
    background-size: contain;
    position: absolute;
    border: none;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 5em;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10;
  }

  .on.off {
    background: url(/assets/Mute_Icon.svg)  no-repeat 50% 50%;
    background-size: contain;
  }
</style>

</head>
<body style="margin: 0; overflow: hidden;">
  <audio id="backing">
    <source src="/assets/windchime.mp3" type="audio/mpeg">
  </audio>
  <input type="button" id="toggle" class="on" onclick="togglestyle(this)" />
  <a-scene 
    fog="type: exponential; color: #AAA; density: 0.0005" 
    renderer="logarithmicDepthBuffer: true;"
    vr-mode-ui="enabled: false"

    arjs="sourceType: webcam; debugUIEnabled: false;">
    <a-assets  timeout="100000">
      <a-asset-item id="model-asset" src="./assets/model.glb" />
    </a-assets>

    <a-entity 
      id="model"
      gltf-model="#model-asset"
      spinchanger
      scalechanger
      opacitychanger
      positionchanger
      >
    </a-entity>


    <a-camera gps-projected-camera read-rotation></a-camera>
  </a-scene>
</body>

<script language="javascript">
  var backingEl = document.getElementById("backing");
  var toggleEl = document.getElementById("toggle");

  function onPlay(){
      backingEl.play();
      toggleEl.className="on off";
  }

  function onPause(){
    backingEl.pause();
    toggleEl.className="on";
  }

  function togglestyle(el){      
      if(el.className == "on") {
        onPlay();
      } else {
        onPause();
      }
  }

  backingEl.onended = function(event){
    onPause();
  }
</script>


</html>